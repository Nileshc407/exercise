<?php
//CodeIgniter 
?>
1.CodeIgniter URLs
	By default, URLs in CodeIgniter are designed to be search-engine and human friendly. Rather than using the standard “query string” approach to URLs that is synonymous with dynamic systems, CodeIgniter uses a segment-based approach
	
	#example.com/news/article/my_article
	
	1.URI Segments
		The segments in the URL, in following with the Model-View-Controller approach, usually represent:

		example.com/class/function/ID
		1.The first segment represents the controller class that should be invoked.
		2.The second segment represents the class function, or method, that should be called.
		3.The third, and any additional segments, represent the ID and any variables that will be passed to the controller.

		The URI Library and the URL Helper contain functions that make it easy to work with your URI data. In addition, your URLs can be remapped using the URI Routing feature for more flexibility.
	
	2.Removing the index.php file
	By default, the index.php file will be included in your URLs:

	example.com/index.php/news/article/my_article
	
	3.Adding a URL Suffix
		In your config/config.php file you can specify a suffix that will be added to all URLs generated by CodeIgniter. For example, if a URL is this:

		example.com/index.php/products/view/shoes
		
		You can optionally add a suffix, like .html, making the page appear to be of a certain type:

		example.com/index.php/products/view/shoes.html
		
	4.Enabling Query Strings
		In some cases you might prefer to use query strings URLs:

		index.php?c=products&m=view&id=345
		CodeIgniter optionally supports this capability, which can be enabled in your application/config.php file. If you open your config file you’ll see these items:
		<?php
			$config['enable_query_strings'] = FALSE;
			$config['controller_trigger'] = 'c';
			$config['function_trigger'] = 'm';
		 ?>
		If you change “enable_query_strings” to TRUE this feature will become active. Your controllers and functions will then be accessible using the “trigger” words you’ve set to invoke your controllers and methods:

		index.php?c=controller&m=method
		
		Note

		If you are using query strings you will have to build your own URLs, rather than utilizing the URL helpers (and other helpers that generate URLs, like some of the form helpers) as these are designed to work with segment based URLs.
		
2.What is a Controller?
	A Controller is simply a class file that is named in a way that can be associated with a URI.

	Consider this URI:
		example.com/index.php/blog/
	
	In the above example, CodeIgniter would attempt to find a controller named Blog.php and load it.

	When a controller’s name matches the first segment of a URI, it will be loaded.
	
	Let’s try it: Hello World!
  
	Let’s create a simple controller so you can see it in action. Using your text editor, create a file called Blog.php, and put the following code in it:
	
	<?php
		class Blog extends CI_Controller 
		{
			public function index()
			{
				echo 'Hello World!';
			}
		}
	?>
	Now visit the your site using a URL similar to this:

	example.com/index.php/blog/
	If you did it right, you should see:

	Hello World!
	
	Important

	Class names must start with an uppercase letter.
	
	#This is valid:

	<?php
	class Blog extends CI_Controller 
	{

	} ?>
	
	#This is not valid:

	<?php
	class blog extends CI_Controller 
	{

	} ?>
	
3.Methods
	In the above example the method name is index(). The “index” method is always loaded by default if the second segment of the URI is empty. Another way to show your “Hello World” message would be this:

	example.com/index.php/blog/index/
	The second segment of the URI determines which method in the controller gets called.

	Let’s try it. Add a new method to your controller:
	<?php
		class Blog extends CI_Controller 
		{
			public function index()
			{
				echo 'Hello World!';
			}

			public function comments()
			{
				echo 'Look at this!';
			}
		} ?>
		Now load the following URL to see the comment method:

		example.com/index.php/blog/comments/
		
		You should see your new message.

		Passing URI Segments to your methods
		If your URI contains more than two segments they will be passed to your method as parameters.

		For example, let’s say you have a URI like this:

		example.com/index.php/products/shoes/sandals/123
		Your method will be passed URI segments 3 and 4 (“sandals” and “123”):

		<?php
		class Products extends CI_Controller {

			public function shoes($sandals, $id)
			{
					echo $sandals;
					echo $id;
			}
		} ?>
	Important
		If you are using the URI Routing feature, the segments passed to your method will be the re-routed ones.
		
6.Defining a Default Controller
	CodeIgniter can be told to load a default controller when a URI is not present, as will be the case when only your site root URL is requested. To specify a default controller, open your application/config/routes.php file and set this variable:

	$route['default_controller'] = 'blog';
	
7.Remapping Method Calls
	As noted above, the second segment of the URI typically determines which method in the controller gets called. CodeIgniter permits you to override this behavior through the use of the _remap() method:
	<?PHP
	public function _remap()
	{
		// Some code here...
	} ?>
	#Important
		If your controller contains a method named _remap(), it will always get called regardless of what your URI contains. It overrides the normal behavior in which the URI determines which method is called, allowing you to define your own method routing rules.
	
	The overridden method call (typically the second segment of the URI) will be passed as a parameter to the _remap() method:
	<?php
	public function _remap($method)
	{
			if ($method === 'some_method')
			{
					$this->$method();
			}
			else
			{
					$this->default_method();
			}
	} ?>
	Any extra segments after the method name are passed into _remap() as an optional second parameter. This array can be used in combination with PHP’s call_user_func_array() to emulate CodeIgniter’s default behavior.

	Example:
	<?php
	public function _remap($method, $params = array())
	{
		$method = 'process_'.$method;
		if (method_exists($this, $method))
		{
				return call_user_func_array(array($this, $method), $params);
		}
		show_404();
	} ?>
	
8.Processing Output
	CodeIgniter has an output class that takes care of sending your final rendered data to the web browser automatically. More information on this can be found in the Views and Output Class pages. In some cases, however, you might want to post-process the finalized data in some way and send it to the browser yourself. CodeIgniter permits you to add a method named _output() to your controller that will receive the finalized output data.

	Important
		If your controller contains a method named _output(), it will always be called by the output class instead of echoing the finalized data directly. The first parameter of the method will contain the finalized output.

	Here is an example:
	<?php
	public function _output($output)
	{
		echo $output;
	} ?>
	
9.Class Constructors 
	If you intend to use a constructor in any of your Controllers, you MUST place the following line of code in it:

	parent::__construct();
	The reason this line is necessary is because your local constructor will be overriding the one in the parent controller class so we need to manually call it.

	Example:

	<?php
	class Blog extends CI_Controller 
	{
		public function __construct()
		{
				parent::__construct();
				// Your own constructor code
		}
	} ?>
	Constructors are useful if you need to set some default values, or run a default process when your class is instantiated. Constructors can’t return a value, but they can do some default work.
	
10.Reserved Names
	In order to help out, CodeIgniter uses a series of function, method, class and variable names in its operation. Because of this, some names cannot be used by a developer. Following is a list of reserved names that cannot be used.
	
	1.Controller names
		Since your controller classes will extend the main application controller you must be careful not to name your methods identically to the ones used by that class, otherwise your local methods will override them. The following is a list of reserved names. Do not name your controller any of these:
		
		1.CI_Controller
		2.Default
		3.index
		
	2.Functions
		1.is_php()
		2.is_really_writable()
		3.load_class()
		4.is_loaded()
		5.get_config()
		6.config_item()
		7.show_error()
		8.show_404()
		9.log_message()
		10.set_status_header()
		11.get_mimes()
		12.html_escape()
		13.remove_invisible_characters()
		14.is_https()
		15.function_usable()
		16.get_instance()
		17._error_handler()
		18._exception_handler()
		19._stringify_attributes()
			
	3.Variables
		1.$config
		2.$db
		3.$lang
		
	4.Constants
		1.ENVIRONMENT
		2.FCPATH
		3.SELF
		4.BASEPATH
		5.APPPATH
		6.VIEWPATH
		7.CI_VERSION
		8.MB_ENABLED
		9.ICONV_ENABLED
		10.UTF8_ENABLED
		11.FILE_READ_MODE
		12.FILE_WRITE_MODE
		13.DIR_READ_MODE
		14.DIR_WRITE_MODE
		15.FOPEN_READ
		16.FOPEN_READ_WRITE
		17.FOPEN_WRITE_CREATE_DESTRUCTIVE
		18.FOPEN_READ_WRITE_CREATE_DESTRUCTIVE
		19.FOPEN_WRITE_CREATE
		20.FOPEN_READ_WRITE_CREATE
		21.FOPEN_WRITE_CREATE_STRICT
		22.FOPEN_READ_WRITE_CREATE_STRICT
		23.SHOW_DEBUG_BACKTRACE
		24.EXIT_SUCCESS
		25.EXIT_ERROR
		26.EXIT_CONFIG
		27.EXIT_UNKNOWN_FILE
		28.EXIT_UNKNOWN_CLASS
		29.EXIT_UNKNOWN_METHOD
		28.EXIT_USER_INPUT
		29.EXIT_DATABASE
		30.EXIT__AUTO_MIN
		31.EXIT__AUTO_MAX
		
11.Views
	A view is simply a web page, or a page fragment, like a header, footer, sidebar, etc. In fact, views can flexibly be embedded within other views (within other views, etc., etc.) if you need this type of hierarchy.

	Views are never called directly, they must be loaded by a controller. Remember that in an MVC framework, the Controller acts as the traffic cop, so it is responsible for fetching a particular view. If you have not read the Controllers page you should do so before continuing.
	
	Using the example controller you created in the controller page, let’s add a view to it.

	Creating a View
		Using your text editor, create a file called blogview.php, and put this in it:

		<html>
		<head>
				<title>My Blog</title>
		</head>
		<body>
				<h1>Welcome to my Blog!</h1>
		</body>
		</html>
		
	1.Loading a View
		To load a particular view file you will use the following method:

		$this->load->view('name');
		
		Now, open the controller file you made earlier called Blog.php, and replace the echo statement with the view loading method:

		<?php
		class Blog extends CI_Controller {

			public function index()
			{
				$this->load->view('blogview');
			}
		} ?>
		
	2.Loading multiple views
		CodeIgniter will intelligently handle multiple calls to $this->load->view() from within a controller. If more than one call happens they will be appended together. For example, you may wish to have a header view, a menu view, a content view, and a footer view. That might look something like this:

		<?php
		class Page extends CI_Controller {
			public function index()
			{
				$data['page_title'] = 'Your title';
				$this->load->view('header');
				$this->load->view('menu');
				$this->load->view('content', $data);
				$this->load->view('footer');
			}
		} ?>
		
	3.Storing Views within Sub-directories
		Your view files can also be stored within sub-directories if you prefer that type of organization. When doing so you will need to include the directory name loading the view. Example:

		$this->load->view('directory_name/file_name');
		
	4.Adding Dynamic Data to the View
		Data is passed from the controller to the view by way of an array or an object in the second parameter of the view loading method. Here is an example using an array:
			<?php
			$data = array(
					'title' => 'My Title',
					'heading' => 'My Heading',
					'message' => 'My Message'
			);

			$this->load->view('blogview', $data);
			?>
		
		And here’s an example using an object:
			<?php
				$data = new Someclass();
				$this->load->view('blogview', $data);
			?>
		
		Let’s try it with your controller file. Open it add this code:
			<?php 
				class Blog extends CI_Controller {
					public function index()
					{
							$data['title'] = "My Real Title";
							$data['heading'] = "My Real Heading";

							$this->load->view('blogview', $data);
					}
				} ?>

12.Models
	Models are optionally available for those who want to use a more traditional MVC approach.
	
	1.What is a Model?
		Models are PHP classes that are designed to work with information in your database. For example, let’s say you use CodeIgniter to manage a blog. You might have a model class that contains functions to insert, update, and retrieve your blog data. Here is an example of what such a model class might look like:
	
	<?php
		class Blog_model extends CI_Model 
		{
			public $title;
			public $content;
			public $date;

			public function get_last_ten_entries()
			{
				$query = $this->db->get('entries', 10);
				return $query->result();
			}

			public function insert_entry()
			{
				$this->title    = $_POST['title']; // please read the below note
				$this->content  = $_POST['content'];
				$this->date     = time();

				$this->db->insert('entries', $this);
			}

			public function update_entry()
			{
				$this->title    = $_POST['title'];
				$this->content  = $_POST['content'];
				$this->date     = time();

				$this->db->update('entries', $this, array('id' => $_POST['id']));
			}
		} ?>
	2.Anatomy of a Model
		Model classes are stored in your application/models/ directory. They can be nested within sub-directories if you want this type of organization.

		The basic prototype for a model class is this:
		<?php
		class Model_name extends CI_Model {

		} ?>
		Where Model_name is the name of your class. Class names must have the first letter capitalized with the rest of the name lowercase. Make sure your class extends the base Model class.

		The file name must match the class name. For example, if this is your class:
		<?php
		class User_model extends CI_Model {

		} ?>
		Your file will be this:

		application/models/User_model.php
		
	3.Loading a Model
		Your models will typically be loaded and called from within your controller methods. To load a model you will use the following method:
		<?php
			$this->load->model('model_name');
		?>
		
		If your model is located in a sub-directory, include the relative path from your models directory. For example, if you have a model located at application/models/blog/Queries.php you’ll load it using:
		<?php
			$this->load->model('blog/queries');
		?>
		
		Once loaded, you will access your model methods using an object with the same name as your class:
		<?php
			$this->load->model('model_name');

			$this->model_name->method();
		?>
		
		Here is an example of a controller, that loads a model, then serves a view:
		<?php
			class Blog_controller extends CI_Controller 
			{
				public function blog()
				{
						$this->load->model('blog');

						$data['query'] = $this->blog->get_last_ten_entries();

						$this->load->view('blog', $data);
				}
			}
       ?>
		1.Auto-loading Models
			If you find that you need a particular model globally throughout your application, you can tell CodeIgniter to auto-load it during system initialization. This is done by opening the application/config/autoload.php file and adding the model to the autoload array.
			
13.Connecting to your Database
	When a model is loaded it does NOT connect automatically to your database. The following options for connecting are available to you:

	You can connect using the standard database methods described here, either from within your Controller class or your Model class.

	You can tell the model loading method to auto-connect by passing TRUE (boolean) via the third parameter, and connectivity settings, as defined in your database config file will be used:
	<?php
		$this->load->model('model_name', '', TRUE);
	?>
	You can manually pass database connectivity settings via the third parameter:
	<?php
		$config['hostname'] = 'localhost';
		$config['username'] = 'myusername';
		$config['password'] = 'mypassword';
		$config['database'] = 'mydatabase';
		$config['dbdriver'] = 'mysqli';
		$config['dbprefix'] = '';
		$config['pconnect'] = FALSE;
		$config['db_debug'] = TRUE;

		$this->load->model('model_name', '', $config);
	?>
	
14.Helper Functions
	Helpers, as the name suggests, help you with tasks. Each helper file is simply a collection of functions in a particular category. There are URL Helpers, that assist in creating links, there are Form Helpers that help you create form elements, Text Helpers perform various text formatting routines, Cookie Helpers set and read cookies, File Helpers help you deal with files, etc.
	
	Unlike most other systems in CodeIgniter, Helpers are not written in an Object Oriented format. They are simple, procedural functions. Each helper function performs one specific task, with no dependence on other functions.

	CodeIgniter does not load Helper Files by default, so the first step in using a Helper is to load it. Once loaded, it becomes globally available in your controller and views.

	Helpers are typically stored in your system/helpers, or application/helpers directory. CodeIgniter will look first in your application/helpers directory. If the directory does not exist or the specified helper is not located there CI will instead look in your global system/helpers/ directory.
	
	1.Loading a Helper
		Loading a helper file is quite simple using the following method:
		<?PHP
			$this->load->helper('name');
		?>
		Where name is the file name of the helper, without the .php file extension or the “helper” part.

		For example, to load the URL Helper file, which is named url_helper.php, you would do this:
		<?php
			$this->load->helper('url');
		?>
		
	2.Loading Multiple Helpers
		If you need to load more than one helper you can specify them in an array, like this:
		<?php
			$this->load->helper(
				array('helper1', 'helper2', 'helper3')
			);
		?>
		
	3.Auto-loading Helpers
		If you find that you need a particular helper globally throughout your application, you can tell CodeIgniter to auto-load it during system initialization. This is done by opening the application/config/autoload.php file and adding the helper to the autoload array.
		
15.Using CodeIgniter Libraries
	All of the available libraries are located in your system/libraries/ directory. In most cases, to use one of these classes involves initializing it within a controller using the following initialization method:
	<?php
		$this->load->library('class_name');
	?>
	
	Where ‘class_name’ is the name of the class you want to invoke. For example, to load the Form Validation Library you would do this:
	<?php
		$this->load->library('form_validation');
	?>
	Once initialized you can use it as indicated in the user guide page corresponding to that class.

	Additionally, multiple libraries can be loaded at the same time by passing an array of libraries to the load method.

	Example:
	<?php
		$this->load->library(array('email', 'table'));
	?>
	
	1.Creating Your Own Libraries
		When we use the term “Libraries” we are normally referring to the classes that are located in the libraries directory and described in the Class Reference of this user guide. In this case, however, we will instead describe how you can create your own libraries within your application/libraries directory in order to maintain separation between your local resources and the global framework resources.
		
	<?php
		defined('BASEPATH') OR exit('No direct script access allowed');
		class Someclass 
		{
			public function some_method()
			{
			}
		} ?>
		
16.Using CodeIgniter Drivers
	Drivers are a special type of Library that has a parent class and any number of potential child classes. Child classes have access to the parent class, but not their siblings. Drivers provide an elegant syntax in your controllers for libraries that benefit from or require being broken down into discrete classes.

	Drivers are found in the system/libraries/ directory, in their own sub-directory which is identically named to the parent library class. Also inside that directory is a subdirectory named drivers, which contains all of the possible child class files.

	To use a driver you will initialize it within a controller using the following initialization method:

	<?php $this->load->driver('class_name'); ?>
	
	Where class name is the name of the driver class you want to invoke. For example, to load a driver named “Some_parent” you would do this:

	<?php $this->load->driver('some_parent'); ?>
	
	Methods of that class can then be invoked with:

	<?php $this->some_parent->some_method(); ?>
	
	1.Creating Your Own Drivers
		Driver Directory and File Structure
		
		Sample driver directory and file structure layout:

		/application/libraries/Driver_name
		
		Driver_name.php
		drivers
		Driver_name_subclass_1.php
		Driver_name_subclass_2.php
		Driver_name_subclass_3.php
	
	Note
		In order to maintain compatibility on case-sensitive file systems, the Driver_name directory must be named in the format returned by ucfirst().
		
17.Hooks // https://qasimbadami.wordpress.com/2012/05/18/codeigniter-hooks-tutorial/
	
	CodeIgniter’s Hooks feature provides a means to tap into and modify the inner workings of the framework without hacking the core files. When CodeIgniter runs it follows a specific execution process, diagramed in the Application Flow page. There may be instances, however, where you’d like to cause some action to take place at a particular stage in the execution process. For example, you might want to run a script right before your controllers get loaded, or right after, or you might want to trigger one of your own scripts in some other location.
	
	1.Enabling Hooks
		The hooks feature can be globally enabled/disabled by setting the following item in the application/config/config.php file:
	<?php
		$config['enable_hooks'] = TRUE;
	?>
	
	2.Defining a Hook
		Hooks are defined in the application/config/hooks.php file. Each hook is specified as an array with this prototype:

		<?php
			$hook['pre_controller'] = array(
				'class'    => 'MyClass',
				'function' => 'Myfunction',
				'filename' => 'Myclass.php',
				'filepath' => 'hooks',
				'params'   => array('beer', 'wine', 'snacks')
			);
		?>
		Notes:

			The array index correlates to the name of the particular hook point you want to use. In the above example the hook point is pre_controller. A list of hook points is found below. The following items should be defined in your associative hook array:
			
		1.class The name of the class you wish to invoke. If you prefer to use a procedural function instead of a class, leave this item blank.
		
		2.function The function (or method) name you wish to call.
		
		3.filename The file name containing your class/function.
		
		4.filepath The name of the directory containing your script. Note: Your script must be located in a directory INSIDE your application/ directory, so the file path is relative to that directory. For example, if your script is located in application/hooks/, you will simply use ‘hooks’ as your filepath. If your script is located in application/hooks/utilities/ you will use ‘hooks/utilities’ as your filepath. No trailing slash.
		
		5.params Any parameters you wish to pass to your script. This item is optional.
	
	3.Multiple Calls to the Same Hook
		If want to use the same hook point with more than one script, simply make your array declaration multi-dimensional, like this:
		
		<?php
		$hook['pre_controller'][] = array(
			'class'    => 'MyClass',
			'function' => 'MyMethod',
			'filename' => 'Myclass.php',
			'filepath' => 'hooks',
			'params'   => array('beer', 'wine', 'snacks')
		);

		$hook['pre_controller'][] = array(
			'class'    => 'MyOtherClass',
			'function' => 'MyOtherMethod',
			'filename' => 'Myotherclass.php',
			'filepath' => 'hooks',
			'params'   => array('red', 'yellow', 'blue')
		);
		?>
		Notice the brackets after each array index:
		<?php $hook['pre_controller'][] ?>
		
	4.Hook Points
		The following is a list of available hook points.
		
		1.pre_system 
			 Called very early during system execution. Only the benchmark and hooks class have been loaded at this point. No routing or other processes have happened.
			 
		2.pre_controller 
			 Called immediately prior to any of your controllers being called. All base classes, routing, and security checks have been done.
			 
		3.post_controller_constructor 
			Called immediately after your controller is instantiated, but prior to any method calls happening.
			
		4.post_controller
			Called immediately after your controller is fully executed.
		
		5.display_override 
			 Overrides the _display() method, used to send the finalized page to the web browser at the end of system execution. This permits you to use your own display methodology. Note that you will need to reference the CI superobject with <?php $this->CI =& get_instance() ?> and then the finalized data will be available by calling <?php $this->CI->output->get_output(). ?>
			 
		6.cache_override 
			Enables you to call your own method instead of the _display_cache() method in the Output Library. This permits you to use your own cache display mechanism.
			
		7.post_system 
			Called after the final rendered page is sent to the browser, at the end of system execution after the finalized data is sent to the browser.
			
18.URI Routing
	Typically there is a one-to-one relationship between a URL string and its corresponding controller class/method. The segments in a URI normally follow this pattern:
	
	example.com/class/function/id/
	
	In some instances, however, you may want to remap this relationship so that a different class/method can be called instead of the one corresponding to the URL.

	For example, let’s say you want your URLs to have this prototype:

	example.com/product/1/
	example.com/product/2/
	example.com/product/3/
	example.com/product/4/
	
	1.Setting your own routing rules
		Routing rules are defined in your application/config/routes.php file. In it you’ll see an array called $route that permits you to specify your own routing criteria. Routes can either be specified using wildcards or Regular Expressions.
	2.Wildcards
		A typical wildcard route might look something like this:
	<?php
	$route['product/:num'] = 'catalog/product_lookup'; ?>
	
	In a route, the array key contains the URI to be matched, while the array value contains the destination it should be re-routed to. In the above example, if the literal word “product” is found in the first segment of the URL, and a number is found in the second segment, the “catalog” class and the “product_lookup” method are instead used.

	You can match literal values or you can use two wildcard types:

	(:num) will match a segment containing only numbers. (:any) will match a segment containing any character (except for ‘/’, which is the segment delimiter).
	
	Examples
		Here are a few routing examples:
	<?php
		$route['journals'] = 'blogs'; 
	?>
		A URL containing the word “journals” in the first segment will be remapped to the “blogs” class.
	<?php
		$route['blog/joe'] = 'blogs/users/34';
	?>
		A URL containing the segments blog/joe will be remapped to the “blogs” class and the “users” method. The ID will be set to “34”.
	<?php
		$route['product/(:any)'] = 'catalog/product_lookup';
	?>
	
	3.Reserved Routes
		
		There are three reserved routes:
	<?php 
		$route['default_controller'] = 'welcome';
	?>
		This route points to the action that should be executed if the URI contains no data, which will be the case when people load your root URL. The setting accepts a controller/method value and index() would be the default method if you don’t specify one. In the above example, it is Welcome::index() that would be called.

		Note

		You can NOT use a directory as a part of this setting!

		You are encouraged to always have a default route as otherwise a 404 page will appear by default.
	<?PHP
		$route['404_override'] = '';
	?>
		This route indicates which controller class should be loaded if the requested controller is not found. It will override the default 404 error page. Same per-directory rules as with ‘default_controller’ apply here as well.

		It won’t affect to the show_404() function, which will continue loading the default error_404.php file at application/views/errors/error_404.php.
	<?php
		$route['translate_uri_dashes'] = FALSE;
	?>
	
19.Error Handling
	CodeIgniter lets you build error reporting into your applications using the functions described below. In addition, it has an error logging class that permits error and debugging messages to be saved as text files.
	
	#Note
		By default, CodeIgniter displays all PHP errors. You might wish to change this behavior once your development is complete. You’ll find the error_reporting() function located at the top of your main index.php file. Disabling error reporting will NOT prevent log files from being written if there are errors.
		
	Unlike most systems in CodeIgniter, the error functions are simple procedural interfaces that are available globally throughout the application. This approach permits error messages to get triggered without having to worry about class/function scoping.
	
	| You can enable error logging by setting a threshold over zero. The
	| threshold determines what gets logged. Threshold options are:
	|
	|	0 = Disables logging, Error logging TURNED OFF
	|	1 = Error Messages (including PHP errors)
	|	2 = Debug Messages
	|	3 = Informational Messages
	|	4 = All Messages
	|
	| You can also pass an array with threshold levels to show individual error types
	|
	| 	array(2) = Debug Messages, without Error Messages
	|
	| For a live site you'll usually only enable Errors (1) to be logged otherwise
	| your log files will fill up very fast.
	|

	set log_threshold is 1 in config.php file application/config/config.php
	<?php
		$config['log_threshold'] = 1;
	?>
	
20.Web Page Caching
	CodeIgniter lets you cache your pages in order to achieve maximum performance.

	Although CodeIgniter is quite fast, the amount of dynamic information you display in your pages will correlate directly to the server resources, memory, and processing cycles utilized, which affect your page load speeds. By caching your pages, since they are saved in their fully rendered state, you can achieve performance that nears that of static web pages.
	
	1.How Does Caching Work?
		Caching can be enabled on a per-page basis, and you can set the length of time that a page should remain cached before being refreshed. When a page is loaded for the first time, the cache file will be written to your application/cache folder. On subsequent page loads the cache file will be retrieved and sent to the requesting user’s browser. If it has expired, it will be deleted and refreshed before being sent to the browser.
		
	2.Enabling Caching
		To enable caching, put the following tag in any of your controller methods:
	<?php
		$this->output->cache($n); 
	?>
	#Note
		Where $n is the number of minutes you wish the page to remain cached between refreshes.
		
	3.Deleting Caches
		If you no longer wish to cache a file you can remove the caching tag and it will no longer be refreshed when it expires.

		Note

		Removing the tag will not delete the cache immediately. It will have to expire normally.

		If you need to manually delete the cache, you can use the delete_cache() method:

		// Deletes cache for the currently requested URI
		<?php
			$this->output->delete_cache();

			// Deletes cache for /foo/bar
			$this->output->delete_cache('/foo/bar');
		?>
		
21.Profiling Your Application
	The Profiler Class will display benchmark results, queries you have run, and $_POST data at the bottom of your pages. This information can be useful during development in order to help with debugging and optimization.
	
	1.Initializing the Class
		#Important
			This class does NOT need to be initialized. It is loaded automatically by the Output Library if profiling is enabled as shown below.
		
	2.Enabling the Profiler
		To enable the profiler place the following line anywhere within your Controller methods:
		<?php 
			$this->output->enable_profiler(TRUE);
		?>
		When enabled a report will be generated and inserted at the bottom of your pages.

		To disable the profiler you will use:
		<?php
			$this->output->enable_profiler(FALSE);
		?>
	3.Setting Benchmark Points
		In order for the Profiler to compile and display your benchmark data you must name your mark points using specific syntax.

		Please read the information on setting Benchmark points in the Benchmark Library page.
	4.Enabling and Disabling Profiler Sections
		Each section of Profiler data can be enabled or disabled by setting a corresponding config variable to TRUE or FALSE. This can be done one of two ways. First, you can set application wide defaults with the application/config/profiler.php config file.

		Example:
		<?php
			$config['config']          = FALSE;
			$config['queries']         = FALSE;
		?>
		In your controllers, you can override the defaults and config file values by calling the set_profiler_sections() method of the Output Library:
		<?php
			$sections = array(
				'config'  => TRUE,
				'queries' => TRUE
			);
		
		$this->output->set_profiler_sections($sections);
		?>
		
22.Running via the CLI (Command line interface)
	As well as calling an applications Controllers via the URL in a browser they can also be loaded via the command-line interface (CLI).
	
	1.What is the CLI?
		The command-line interface is a text-based method of interacting with computers. For more information, check the Wikipedia article.
		
	2.Why run via the command-line?
		There are many reasons for running CodeIgniter from the command-line, but they are not always obvious.

		1.Run your cron-jobs without needing to use wget or curl
		2.Make your cron-jobs inaccessible from being loaded in the URL by checking the return value of is_cli().
		3.Make interactive “tasks” that can do things like set permissions, prune cache folders, run backups, etc.
		4.Integrate with other applications in other languages. For example, a random C++ script could call one command and run code in your models!
		
	3.Let’s try it: Hello World!
		Let’s create a simple controller so you can see it in action. Using your text editor, create a file called Tools.php, and put the following code in it:
		<?php
			class Tools extends CI_Controller 
			{
				public function message($to = 'World')
				{
					echo "Hello {$to}!".PHP_EOL;
				}
			}
		?>
		Then save the file to your application/controllers/ folder.

		Now normally you would visit the site using a URL similar to this:

		example.com/index.php/tools/message/to
		
		Instead, we are going to open the terminal in Mac/Linux or go to Run > “cmd” in Windows and navigate to our CodeIgniter project.
	
		$ cd /path/to/project;
		$ php index.php tools message
		
		If you did it right, you should see Hello World! printed.
		
		$ php index.php tools message "John Smith"
		
		Here we are passing it an argument in the same way that URL parameters work. “John Smith” is passed as an argument and the output is:

		Hello John Smith!
		
		That’s it!
			That, in a nutshell, is all there is to know about controllers on the command line. Remember that this is just a normal controller, so routing and _remap() works fine.
			
23.Managing your Applications
	By default it is assumed that you only intend to use CodeIgniter to manage one application, which you will build in your application/ directory. It is possible, however, to have multiple sets of applications that share a single CodeIgniter installation, or even to rename or relocate your application directory.
	
	1.Renaming the Application Directory
		If you would like to rename your application directory you may do so as long as you open your main index.php file and set its name using the $application_folder variable:

		<?php $application_folder = 'application'; ?>
		
	2.Relocating your Application Directory
		It is possible to move your application directory to a different location on your server than your web root. To do so open your main index.php and set a full server path in the $application_folder variable:
		<?php $application_folder = '/path/to/your/application'; ?>
		
	3.Running Multiple Applications with one CodeIgniter Installation
		If you would like to share a common CodeIgniter installation to manage several different applications simply put all of the directories located inside your application directory into their own sub-directory.
		
		For example, let’s say you want to create two applications, named “foo” and “bar”. You could structure your application directories like this:
		
		applications/foo/
		applications/foo/config/
		applications/foo/controllers/
		applications/foo/libraries/
		applications/foo/models/
		applications/foo/views/
		applications/bar/
		applications/bar/config/
		applications/bar/controllers/
		applications/bar/libraries/
		applications/bar/models/
		applications/bar/views/
		
		To select a particular application for use requires that you open your main index.php file and set the $application_folder variable. For example, to select the “foo” application for use you would do this:

		<?php $application_folder = 'applications/foo'; ?>
		
		#Note
			Each of your applications will need its own index.php file which calls the desired application. The index.php file can be named anything you want.
			
24.Handling Multiple Environments
	Developers often desire different system behavior depending on whether an application is running in a development or production environment. For example, verbose error output is something that would be useful while developing an application, but it may also pose a security issue when “live”.
	
25.Alternate PHP Syntax for View Files
	If you do not utilize CodeIgniter’s template engine, you’ll be using pure PHP in your View files. To minimize the PHP code in these files, and to make it easier to identify the code blocks it is recommended that you use PHPs alternative syntax for control structures and short tag echo statements. If you are not familiar with this syntax, it allows you to eliminate the braces from your code, and eliminate “echo” statements.
	
	1.Automatic Short Tag Support
		#Note
			If you find that the syntax described in this page does not work on your server it might be that “short tags” are disabled in your PHP ini file. CodeIgniter will optionally rewrite short tags on-the-fly, allowing you to use that syntax even if your server doesn’t support it. This feature can be enabled in your config/config.php file.
			
		Please note that if you do use this feature, if PHP errors are encountered in your view files, the error message and line number will not be accurately shown. Instead, all errors will be shown as eval() errors.
		
	2.Alternative Echos
		Normally to echo, or print out a variable you would do this:
		
		<?php echo $variable; ?>
		
		With the alternative syntax you can instead do it this way:
		
		<?=$variable?>
		
	3.Alternative Control Structures
		Controls structures, like if, for, foreach, and while can be written in a simplified format as well. Here is an example using 
		
		foreach:
			<ul>
			<?php foreach ($todo as $item): ?>

				<li><?=$item?></li>

			<?php endforeach; ?>
			</ul>
			
		Notice that there are no braces. Instead, the end brace is replaced with endforeach. Each of the control structures listed above has a similar closing syntax: endif, endfor, endforeach, and endwhile

		Also notice that instead of using a semicolon after each structure (except the last one), there is a colon. This is important!

		Here is another example, using if/elseif/else. Notice the colons:
		
		<?php if ($username === 'sally'): ?>

        <h3>Hi Sally</h3>

		<?php elseif ($username === 'joe'): ?>

				<h3>Hi Joe</h3>

		<?php else: ?>

				<h3>Hi unknown user</h3>

		<?php endif; ?>
		
26.Security
	This page describes some “best practices” regarding web security, and details CodeIgniter’s internal security features.
	
	Note

	If you came here looking for a security contact, please refer to our Contribution Guide <../contributing/index>.
	
	1.URI Security
		
		CodeIgniter is fairly restrictive regarding which characters it allows in your URI strings in order to help minimize the possibility that malicious data can be passed to your application. URIs may only contain the following:

		Alpha-numeric text (latin characters only)
		Tilde: ~
		Percent sign: %
		Period: .
		Colon: :
		Underscore: _
		Dash: -
		Space
		
	2.Register_globals
		During system initialization all global variables that are found to exist in the <? $_GET, $_POST, $_REQUEST and $_COOKIE ?>are unset.

		The unsetting routine is effectively the same as register_globals = off.
		
	3.display_errors
		In production environments, it is typically desirable to “disable” PHP’s error reporting by setting the internal display_errors flag to a value of 0. This disables native PHP errors from being rendered as output, which may potentially contain sensitive information.

	Setting CodeIgniter’s ENVIRONMENT constant in index.php to a value of ‘production’ will turn off these errors. In development mode, it is recommended that a value of ‘development’ is used. More information about differentiating between environments can be found on the Handling Environments page.
	
	4.magic_quotes_runtime
		The magic_quotes_runtime directive is turned off during system initialization so that you don’t have to remove slashes when retrieving data from your database.
		
	5.Best Practices
		Before accepting any data into your application, whether it be POST data from a form submission, COOKIE data, URI data, XML-RPC data, or even data from the SERVER array, you are encouraged to practice this three step approach:
		
		1.Validate the data to ensure it conforms to the correct type, length, size, etc.
		2.Filter the data as if it were tainted.
		3.Escape the data before submitting it into your database or outputting it to a browser.
	
	CodeIgniter provides the following functions and tips to assist you in this process:

	6.XSS Filtering
		CodeIgniter comes with a Cross Site Scripting filter. This filter looks for commonly used techniques to embed malicious JavaScript into your data, or other types of code that attempt to hijack cookies or do other malicious things. The XSS Filter is described here.
		
	#Note
		XSS filtering  should only be performed on output. Filtering input data may modify the data in undesirable ways, including stripping special characters from passwords, which reduces security instead of improving it.
		
	7.CSRF protection
		CSRF stands for Cross-Site Request Forgery, which is the process of an attacker tricking their victim into unknowingly submitting a request.

		CodeIgniter provides CSRF protection out of the box, which will get automatically triggered for every non-GET HTTP request, but also needs you to create your submit forms in a certain way. This is explained in the Security Library documentation.
		
	8.Password handling
		It is critical that you handle passwords in your application properly.
		Unfortunately, many developers don’t know how to do that, and the web is full of outdated or otherwise wrongful advices, which doesn’t help.
		
		We would like to give you a list of combined do’s and don’ts to help you with that. Please read below.
		
		1.DO NOT store passwords in plain-text format.
		2.Always hash your passwords. 
		3.DO NOT use Base64 or similar encoding for storing passwords.
		
		This is as good as storing them in plain-text. Really. Do hashing, not encoding.
		
		Encoding, and encryption too, are two-way processes. Passwords are secrets that must only be known to their owner, and thus must work only in one direction. Hashing does that - there’s no un-hashing or de-hashing, but there is decoding and decryption.
		
		4.DO NOT use weak or broken hashing algorithms like MD5 or SHA1.
		
		These algorithms are old, proven to be flawed, and not designed for password hashing in the first place.

		Also, DON’T invent your own algorithms.
		
		Only use strong password hashing algorithms like BCrypt, which is used in PHP’s own Password Hashing functions.
		Please use them, even if you’re not running PHP 5.5+, CodeIgniter provides them for you.

		5.DO NOT ever display or send a password in plain-text format!
		
27.Libraries
	Benchmarking Class
	Caching Driver
	Calendaring Class
	Shopping Cart Class
	Config Class
	Email Class
	Encrypt Class
	Encryption Library
	File Uploading Class
	Form Validation
	FTP Class
	Image Manipulation Class
	Input Class
	Javascript Class
	Language Class
	Loader Class
	Migrations Class
	Output Class
	Pagination Class
	Template Parser Class
	Security Class
	Session Library
	HTML Table Class
	Trackback Class
	Typography Class
	Unit Testing Class
	URI Class
	User Agent Class
	XML-RPC and XML-RPC Server Classes
	Zip Encoding Class

	1.Benchmarking Class
		
	2.Caching Driver
	
	3.Calendaring Class
		The Calendar class enables you to dynamically create calendars. Your calendars can be formatted through the use of a calendar template, allowing 100% control over every aspect of its design. In addition, you can pass data to your calendar cells.
		
		1.Using the Calendaring Class
			
			1.Initializing the Class
				Like most other classes in CodeIgniter, the Calendar class is initialized in your controller using the $this->load->library  function:
				
			<?php $this->load->library('calendar'); ?>
			
			Once loaded, the Calendar object will be available using:

			<?php $this->calendar ?>
			
			2.Displaying a Calendar
				Here is a very simple example showing how you can display a calendar:
			<?php
				$this->load->library('calendar');
				echo $this->calendar->generate();
			?>
			The above code will generate a calendar for the current month/year based on your server time. To show a calendar for a specific month and year you will pass this information to the calendar generating function:
			<?php
				$this->load->library('calendar');
				echo $this->calendar->generate(2006, 6);
			?>
			The above code will generate a calendar showing the month of June in 2006. The first parameter specifies the year, the second parameter specifies the month.
			
		2.Passing Data to your Calendar Cells
		
		#Total days in a given month:
			<? echo $this->calendar->get_total_days(2, 2012); ?>
			// 29
			
	4.Shopping Cart Class
		The Cart Class permits items to be added to a session that stays active while a user is browsing your site. These items can be retrieved and displayed in a standard “shopping cart” format, allowing the user to update the quantity or remove items from the cart.
		
		Important
			The Cart library is DEPRECATED and should not be used. It is currently only kept for backwards compatibility.
			
		Please note that the Cart Class ONLY provides the core “cart” functionality. It does not provide shipping, credit card authorization, or other processing components.
		
		1.Using the Cart Class
		2.Initializing the Shopping Cart Class
		3.Adding an Item to The Cart
		4.Adding Multiple Items to The Cart
		5.Displaying the Cart
		6.Updating The Cart
		7.What is a Row ID?
		8.Class Reference
		
			1.Using the Cart Class
			
			1.1.Initializing the Shopping Cart Class
				#Important

				The Cart class utilizes CodeIgniter’s Session Class to save the cart information to a database, so before using the Cart class you must set up a database table as indicated in the Session Documentation, and set the session preferences in your application/config/config.php file to utilize a database.

				To initialize the Shopping Cart Class in your controller constructor, use the $this->load->library() method:

				<?php $this->load->library('cart'); ?>
				Once loaded, the Cart object will be available using:

				<? $this->cart ?>
				
				#Note

					The Cart Class will load and initialize the Session Class automatically, so unless you are using sessions elsewhere in your application, you do not need to load the Session class.
					
				 1.Adding an Item to The Cart
					To add an item to the shopping cart, simply pass an array with the product information to the $this->cart->insert() method, as shown below:
				<?php	
					$data = array(
						'id'      => 'sku_123ABC',
						'qty'     => 1,
						'price'   => 39.95,
						'name'    => 'T-Shirt',
						'options' => array('Size' => 'L', 'Color' => 'Red')
					);

					$this->cart->insert($data); ?>
					
					#Important

					The first four array indexes above (id, qty, price, and name) are required. If you omit any of them the data will not be saved to the cart. The fifth index (options) is optional. It is intended to be used in cases where your product has options associated with it. Use an array for options, as shown above.

					The five reserved indexes are:

					1.id - Each product in your store must have a unique identifier. Typically this will be an “sku” or other such identifier.
					2.qty - The quantity being purchased.
					3.price - The price of the item.
					4.name - The name of the item.
					5.options - Any additional attributes that are needed to identify the product. These must be passed via an array.
					
					In addition to the five indexes above, there are two reserved words: rowid and subtotal. These are used internally by the Cart class, so please do NOT use those words as index names when inserting data into the cart.

					Your array may contain additional data. Anything you include in your array will be stored in the session. However, it is best to standardize your data among all your products in order to make displaying the information in a table easier.
				<?
					$data = array(
							'id'      => 'sku_123ABC',
							'qty'     => 1,
							'price'   => 39.95,
							'name'    => 'T-Shirt',
							'coupon'         => 'XMAS-50OFF'
					);

					$this->cart->insert($data); ?>
					The insert() method will return the $rowid if you successfully insert a single item.
					
				2.Adding Multiple Items to The Cart
					By using a multi-dimensional array, as shown below, it is possible to add multiple products to the cart in one action. This is useful in cases where you wish to allow people to select from among several items on the same page.
					<?php
						$data = array(
							array(
									'id'      => 'sku_123ABC',
									'qty'     => 1,
									'price'   => 39.95,
									'name'    => 'T-Shirt',
									'options' => array('Size' => 'L', 'Color' => 'Red')
							),
							array(
									'id'      => 'sku_567ZYX',
									'qty'     => 1,
									'price'   => 9.95,
									'name'    => 'Coffee Mug'
							),
							array(
									'id'      => 'sku_965QRS',
									'qty'     => 1,
									'price'   => 29.95,
									'name'    => 'Shot Glass'
							)
						);

					$this->cart->insert($data);
				?>
				
				3.Displaying the Cart
					To display the cart you will create a view file with code similar to the one shown below.

					Please note that this example uses the form helper.
					
					<?php echo form_open('path/to/controller/update/method'); ?>

						<table cellpadding="6" cellspacing="1" style="width:100%" border="0">

						<tr>
								<th>QTY</th>
								<th>Item Description</th>
								<th style="text-align:right">Item Price</th>
								<th style="text-align:right">Sub-Total</th>
						</tr>

						<?php $i = 1; ?>

						<?php foreach ($this->cart->contents() as $items): ?>

								<?php echo form_hidden($i.'[rowid]', $items['rowid']); ?>

								<tr>
										<td><?php echo form_input(array('name' => $i.'[qty]', 'value' => $items['qty'], 'maxlength' => '3', 'size' => '5')); ?></td>
										<td>
												<?php echo $items['name']; ?>

												<?php if ($this->cart->has_options($items['rowid']) == TRUE): ?>

														<p>
																<?php foreach ($this->cart->product_options($items['rowid']) as $option_name => $option_value): ?>

																		<strong><?php echo $option_name; ?>:</strong> <?php echo $option_value; ?><br />

																<?php endforeach; ?>
														</p>

												<?php endif; ?>

										</td>
										<td style="text-align:right"><?php echo $this->cart->format_number($items['price']); ?></td>
										<td style="text-align:right">$<?php echo $this->cart->format_number($items['subtotal']); ?></td>
								</tr>

						<?php $i++; ?>

						<?php endforeach; ?>

						<tr>
								<td colspan="2"> </td>
								<td class="right"><strong>Total</strong></td>
								<td class="right">$<?php echo $this->cart->format_number($this->cart->total()); ?></td>
						</tr>

						</table>

						<p><?php echo form_submit('', 'Update your Cart'); ?></p>
						
				4.Updating The Cart
					To update the information in your cart, you must pass an array containing the Row ID and one or more pre-defined properties to the $this->cart->update() method.
					
					Note

						If the quantity is set to zero, the item will be removed from the cart.
					<?php	
						$data = array(
								'rowid' => 'b99ccdf16028f015540f341130b6d8ec',
								'qty'   => 3
						);

						$this->cart->update($data);

						// Or a multi-dimensional array

						$data = array(
								array(
										'rowid'   => 'b99ccdf16028f015540f341130b6d8ec',
										'qty'     => 3
								),
								array(
										'rowid'   => 'xw82g9q3r495893iajdh473990rikw23',
										'qty'     => 4
								),
								array(
										'rowid'   => 'fh4kdkkkaoe30njgoe92rkdkkobec333',
										'qty'     => 2
								)
						);

						$this->cart->update($data);
					?>
					You may also update any property you have previously defined when inserting the item such as options, price or other custom fields.
					<?php
					$data = array(
							'rowid'  => 'b99ccdf16028f015540f341130b6d8ec',
							'qty'    => 1,
							'price'  => 49.95,
							'coupon' => NULL
					);

					$this->cart->update($data); ?>
					
				5.What is a Row ID?
					The row ID is a unique identifier that is generated by the cart code when an item is added to the cart. The reason a unique ID is created is so that identical products with different options can be managed by the cart.

					For example, let’s say someone buys two identical t-shirts (same product ID), but in different sizes. The product ID (and other attributes) will be identical for both sizes because it’s the same shirt. The only difference will be the size. The cart must therefore have a means of identifying this difference so that the two sizes of shirts can be managed independently. It does so by creating a unique “row ID” based on the product ID and any options associated with it.

					In nearly all cases, updating the cart will be something the user does via the “view cart” page, so as a developer, it is unlikely that you will ever have to concern yourself with the “row ID”, other than making sure your “view cart” page contains this information in a hidden form field, and making sure it gets passed to the update() method when the update form is submitted. Please examine the construction of the “view cart” page above for more information.
					      
	5.Config Class
	
	6.Email Class
		CodeIgniter’s robust Email Class supports the following features:

		Multiple Protocols: Mail, Sendmail, and SMTP
		TLS and SSL Encryption for SMTP
		Multiple recipients
		CC and BCCs
		HTML or Plaintext email
		Attachments
		Word wrapping   
		Priorities
		BCC Batch Mode, enabling large email lists to be broken into small BCC batches.
		Email Debugging tools